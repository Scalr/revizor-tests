# coding: utf-8
"""
Created on 18.06.18
@author: Eugeny Kurkovich
"""
import re
import os

import pytest
import requests

from six import string_types

from pyswagger import App
from box import Box
from flex.core import load as load_schema_from_file, validate as flex_validate_response

from api.utils.api_session import ScalrApiSession
from api.utils.helpers import serialize_platform_store
from api.utils.helpers import remove_empty_values
from api.utils.consts import APIParams
from api.utils.exceptions import ResponseValidationError


class AppSession(object):
    _app = None
    _app_tree = None
    _api_session = None

    successful_response_codes = dict(
        GET=[200],
        PATCH=[200],
        POST=[200, 201],
        DELETE=[204]
    )

    def __init__(self, request, fileutil):
        schema = fileutil.get_swagger_definitions()
        self._app = App.create(schema)
        self._app_tree = Box(AppSession._get_schema_tree(self._app.root.paths.keys()))
        self._request = request
        self.scopes = {
            'user': {
                'spec': None,
                'swagger': None,
                'flex': None
            },
            'global': {
                'spec': None,
                'swager': None,
                'flex': None
            }
        }
        self.spec_path = request.config.working_dir / 'specs'

    def __getattr__(self, name):
        def _handler(*args, **kwargs):
            if len(args) == 1:
                if not isinstance(args[0], string_types):
                    raise ValueError('Request args mismatch')
            else:
                raise ValueError('Request session expected at most 1 argument, got {0}'.format(len(args)))
            kwargs['method'] = name
            return self._execute_request(*args, **kwargs)
        return _handler

    def get_swagger_specs(self, scope='user'):
        if self.scope[scope]['spec'] is None:
            path = self.spec_path / 'v1beta0-{}-autogenerated.yaml'.format(scope)
            if not path.exists():
                self.download_spec(scope)
            self.scope[scope]['spec'] = path
        return self.scope[scope]['spec']

    def download_spec(self, scope='user'):
        spec = requests.get(
            'http://{}/api/{}.v1beta0.yml'.format(self._request.config.api_environment.host, scope)
        )
        with open(self.spec_path / '{}-autogenerated.yaml', 'w+') as sp:
            sp.write(spec.content)

    def close(self):
        self._api_session.close()

    def _execute_request(self, endpoint, method, params=None, filters=None, body=None):
        request_kwargs = dict(
            method=method,
            endpoint=self._parse_endpoint(endpoint),
            params=params or {},
            body=body,
            filters=filters
        )

        scope = endpoint.split('/')[3]



        req_params = self.check_request_params(
            self._get_request_spec_by_endpoint(endpoint),
            request_kwargs)

        api = ScalrApiSession(
            host=self._request.config.api_environment.host,
            secret_key_id=self._request.config.api_environment.config['{}_api'.format(scope)]['id'],
            secret_key=self._request.config.api_environment.config['{}_api'.format(scope)]['secret']
        )

        response = api.request(
            serializer=serialize_platform_store,
            **req_params
        )

        self.request_ok(response)

        if self._request.config.getoption("flex_validation"):
            self.validate_response(scope, response)
        return response

    def request_ok(self, response):
        response_successful_code = self.successful_response_codes.get(response.request.method)
        if response.status_code not in response_successful_code:
            raise ResponseValidationError('Response successful code not valid')

    def validate_response(self, scope, data):
        """
        :type: data: requests.Response
        :param data: raw requests.response

        :type: flex_validation: bool
        :param: flex_validation: Enabled response validation by flex

        :return: None or validation error
        """
        if not isinstance(data, requests.models.Response):
            raise ValueError('Not valid data format')

        if self.scopes[scope]['flex'] is None:
            self.scopes[scope]['flex'] = load_schema_from_file(self.get_swagger_specs(scope))

        data = data.json()
        flex_validate_response(
            self._flex[scope],
            data
        )

    @staticmethod
    def check_request_params(schema, req_params):
        method = req_params.get('method')
        params = req_params.get('params')
        filters = remove_empty_values(req_params.get('filters'))
        body = remove_empty_values(req_params.get('body'))
        required_params = []

        # Validate request type
        available_methods = {rt: m for rt, m in APIParams.request_types.items() if m in schema.keys()}
        http_meth = available_methods.get(method)
        if not http_meth:
            raise ValueError("Not supported endpoint request type, got {0}, expected {1}".format(
                method,
                available_methods.keys()))

        # Validate request required params
        if not isinstance(params, dict):
            raise TypeError('Request params mismatch')
        if 'parameters' in schema[http_meth]:
            required_params = [p.name for p in schema[http_meth].parameters if p.required]
        if not list(params.keys()).sort() == required_params.sort():
            raise ValueError("Not enough required parameters got {0}, expected {1}".format(
                params,
                required_params))
        return dict(
            method=http_meth,
            endpoint=req_params.get('endpoint'),
            params=params,
            body=body,
            filters=filters)

    @staticmethod
    def _get_schema_tree(root):
        r = dict()
        for path in root:
            path_items = re.sub(r"[\{\}]", "", path).split("/")
            key = os.path.join(*filter(None, path_items))
            r[key] = path
        return r

    def _path_from_endpoint(self, endpoint):
        path_items = filter(None, endpoint.split(self._app_root)[1].split('/'))
        endpoint = os.path.join(*path_items)
        return getattr(self._app_tree, endpoint)

    def _get_request_spec_by_endpoint(self, endpoint):
        try:
            path = self._path_from_endpoint(endpoint)
            return Box(self._app.s(path).dump())
        except Exception:
            raise ValueError("Endpoint {} does not exists".format(endpoint))

    def _parse_endpoint(self, endpoint):
        path = self._path_from_endpoint(endpoint)
        return os.path.join(self._app_root, *filter(None, path.split('/')))


@pytest.fixture(scope='module', autouse=True)
def api(request, fileutil):
    session = AppSession(request, fileutil)
    request.addfinalizer(session.close)
    return session

