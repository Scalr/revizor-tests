## Обзор

UI тесты реализованы при помощи Pytest, Selenium Webdriver и Python Page Obejct библиотеки.
Основная идея - предоставить стабильную библиотеку для написания автоматизированных UI тестов, которые будут покрывать наиболее часто проверяемые сценарии и регресси (аналог lifecycle тестов базового revizor).
Проект следует архитектуре PageObject - функционал отдельной взятой страницы выносится в отдельный класс.

## Основные структурные элементы

 * Локаторы (ui/elements/locators.py)
 * Базовые элементы страницы (ui/elements/base)
 * Page объекты (ui/elements/page_object)
 * Классы страниц (ui/pages/..)

## Локаторы

Локаторы - это данные, необходимые Selenium Webdriver для поиска элементов страницы. 
Изначально представляют из себя tuple с типом локатора и его значением:
```
('xpath', '//div [contains(text(), "TEST")]')
```
Для упрощения работы были созданы отдельные классы для каждого из их типов, которые принимают только значение самого локтора и возвращают необходимый объект:
```
from elements.locators import IdLocator
locator = IdLocator('menuitem-1997')
```
ВАЖНО! Если необходимого типа локатора в модуле locators нет, Вам следует его туда добавить.

## Базовые элементы

Элементы страницы, с которыми мы взаимодействуем в ходе теста, представлены в виде отдельных классов для каждого типа элемента (кнопка, дропдаун, попап и т.д.)
Эти элементы наследуются от базового класса elements.base.BaseElement, который содержит общие методы для всех типов элементов:
 * text - возвращает текст элемента (все выводимые надписи).
 * get_element - возвращает объект Selenium element.
 * list_elements - возвращает список всех элементов, соответствующих критерию данного локатора.
 * mouse_over - переводит курсор мыши на середину элемента. ВАЖНО! При локальном запуске для работы этой функции необходимо, чтобы окно браузера было текущим активным (верхним).
 * visible/hidden - проверка статуса отображения элемента.
 * scroll_into_view - скролл страницы до состояния видимости элемента.

Каждый класс элемента имеет свой набор keyword аргументов для поиска элемента на странице. К примеру, Button можно найти по тексту, имени, href, иконке и т.д.
При передаче значения в нужный аргумент класс автоматически создаст необходимый локатор и попытается найти элемент на странице.
Для нестандартных элементов следует использовать аргумент xpath и передачу соответственного XPath'a.
Пример:
```
from elements.base import Button
Button(text='Save farm').click()
```
ИЛИ
```
from elements.base import Button
Button(xpath='//a [contains(text(), "Save Farm")]').click()
```
У каждого типа элемента свой набор аргументов для инициализации.
Также, некоторые элементы имеют дополнительные фукнции - click() у Button, write() у Input, select() у Menu и т.д.
Для инициализации элемента также необходим селениум драйвер.
Если элемент прописан в атрибутах класса страницы, то передавать ему драйвер не надо (он унаследует его от страницы):
```
class Images(EnvironmentTopMenu):
    URL_TEMPLATE = '/#/images'
    new_image_button = Button(text="New image")
```

Если же элемент инициализируется в коде метода класса или коде теста, то ему ОБЯЗАТЕЛЬНО надо прокинуть драйвер через keyword argument:
```
Button(text="New image", driver=driver).click()
```

## Page объекты

Это особые комплексные элементы страницы с собственными методами, которые невозможно покрыть использованием базовых элементов.
Пример - главное боковое попап меню Scalr. 
Эти объекты описываются отдельными классами с собственными методами, но НЕ наследуются от базового класса страницы Page.

## Классы страниц

Эти классы описывают весь необходимый в тестах функционал отдельно взятой страницы Scalr, к примеру Login Page.
Они содержат элементы, с которыми можно взаимодействовать:
```
from pages.login import LoginPage
lp = LoginPage(driver, "http://...").open()
lp.login_button.click()
```
Также они содержат функции, в которые вынесены отдельные стандартные функциональные действия:
```
from pages.login import LoginPage
lp = LoginPage(driver, "http://...").open()
lp.login('user', 'password')
```
Функции, делающие редирект на другую страницу, должны возвращать инициализированный объект класса этой страницы.
```
from pages.environment_scope import EnvironmentDashboard
ed = EnvironmentDashboard(driver, "http://")
account_dashboard = ed.go_to_account()
```

Классы страниц наследуются от базового класса pages.base.BasePage (который, в свою очередь, наследуется от класcа Page библиотеки PyPOM).
Для инициализации им необходим объект selenium драйвера и базовый URL страницы.
У каждого класса есть URL_TEMPLATE, представляющий собой "суффикс" страницы. Реальный URL собирается как базовый URL (переданный при инициализации) + URL_TEMPLATE.

У каждого класса страницы есть @property loaded, по которому определяется завершение прогрузки страницы.
При открытии (.open()) страницы встроенный поллер проверяет результат выполнения loaded. Если он True - страница считается прогруженной.
Если loaded не возвращает True в течение 30 секунд (базовый таймаут) - выводится ошибка.
Проперти loaded необходимо описывать для каждого класса. Самый простой вариант - проверка видимости какого-нибудь элемента на странице (.visible())

На данный момент существуют классы, описывающие работу бокового PopUp меню и верхнего меню Scalr.
pages.common.CommonTopMenu описывает функционал, доступный на всех скоупах и дает доступ к боковому меню.
pages.environment_scope.EnvironmentTopMenu и pages.environment_scope.AccountTopMenu наследуются от CommonTopMenu и добавляют функционал, специфический для соответствующего скоупа.

Классы страниц в скоупе обычно наследуются от класса *TopMenu соответствующего скоупа, если на этой странице доступно верхнее меню Scalr.
```
class ACL(AccountTopMenu):
```

## Фикстуры
Фикстуры описаны в ui/fixtures и ui/conftest.
В conftest описана фикстура, которая сохраняет скриншот окна браузера при падении теста. 
Скриншот сохраняется в формате PNG в основной папке, из которой был произведен запуск (обычно /vagrant | /revizor-tests).
У каждого скриншота в имени содержится название кейса и уникальный айди.
ВАЖНО! Пока что нет автоматической чистилки скриншотов, подчищать за собой придется руками.

Фикстура fixtures.testenv отвечает за запуск и работу с TestEnv контейнером на Web Revizor. 
При успешном выполнении теста контейнер удаляется автоматически.
При падении теста контейнер оставляется для последующего дебаггинга.
ВАЖНО! Не забывать подчищать за собой BuildBot контейнеры, оставшиеся после упавших тестов.
Автоматическая чистилка будет сделана позднее.

Фикстура selenium предоставляется сторонней библиотекой pytest-selenium и необходима для инициализации селениум драйвера.

В тестах фикстуры драйвера и создания TestEnv следует включать в setUp метод:
```
    @pytest.fixture(autouse=True)
    def prepare_env(self, selenium, testenv):
        self.driver = selenium
        self.container = testenv
```

## Настройка рабочего окружения

Основное окружение поднимается при помощи Vagrant и Docker.
В папке revizor-tests необходимо выполнить vagrant up, после чего автоматически соберется виртуалка Ubuntu с установленными зависимостями и поднятыми докер контейнерами Selenium Hub.
Файлы зависимостей, скрипты и invoke таски по настройке окружения находятся в ui/ci/.
ВАЖНО! Все тесты должны запускаться через python 3 (python версии 3.6.5 установлен по-умолчанию).

Самый простой пример настройки окружения и запуска тестов:
```
cd ../revizor-tests
vagrant up
vagrant ssh
cd /vagrant
invoke webtests
```

Selenium драйвера для Firefox и Chrome представлены в виде docker контейнеров, объединенных в Selenium Hub.
Эти контейнеры можно повторно запустить, вызвав invoke таск grid:
```
cd /vagrant
invoke grid
```

Для запуска тестов можно воспользоваться invoke таском webtests.
Таск принимает несколько опциональных аргументов:
 * testpath - путь к конкретному файлу теста/папке с тестами. По-умолчанию таск будет находить и запускать все тесты в ui/.
 * browsers - список браузеров, на которых надо прогнать тесты. По-умолчанию это firefox и chrome.
 * processes - количество процессов для распараллеливания тестов. По-умолчанию запускает все тесты последовательно.
 * localmode - для запуска тестов на локальной машине. ВАЖНО! Предварительно надо установить драйвера, см. секцию "Локальный запуск".
Пример:
```
invoke webtests --testpath ui/test_foo.py::TestFoo --browsers firefox,chrome --processes 3 --localmode true
```


## Локальный запуск
Локальный запуск необходим для активного дебаггинга, т.к. только при локальном запуске можно непосредственно наблюдать за окном браузера при ране теста.
На вашей локальной машине должны быть установлены браузеры Firefox и Chrome, желательно более-мене свежей версии.

Для локального запуска необходимо установить зависимости вручную и выполнить Invoke таск seleniumdrivers, который установит chromedriver и geckodriver на вашу локальную машину.
```
cd ../revizor-tests
invoke seleniumdrivers
```
Таск seleniumdrivers актуален для Linux и MacOS систем. На Windows он выкинет ошибку и попросит установить драйвера вручную.

## Работа тестов

В ходе каждого рана теста автоматически создается TestEnv контейнер c юзером BuildBot на Web Revizor.
Каждый отдельный кейс открывает новое окно браузера (по-этому в setUp метод обычно выносится фукнционал логина в Scalr).
При падении отдельного теста в кейсе, в фолдере, из которого был запущен тест, создается скриншот окна браузера. В имени скриншота содержится название кейса и уникальное айди.

При успешном выполнении всего сьюта созданный TestEnv автоматически удаляется.
В противном случае TestEnv остается для дебаггинга. Подчищать его придется руками. Это можно сделать через ipython.
Пример:
```
from revizor2.testenv import TestEnv
TestEnv(<container-id>).destroy()
```
ВАЖНО! Не удалите чужой контейнер =)




