# Обзор

UI тесты реализованы при помощи Pytest, Selene и использует PageObject Pattern.
Основная идея - предоставить стабильную библиотеку для написания автоматизированных UI тестов, которые будут покрывать наиболее часто проверяемые сценарии и регресси.
Проект следует архитектуре PageObject - функционал отдельной взятой страницы выносится в отдельный класс.

## Основные структурные элементы

 * Базовые элементы страницы (utils/components)
 * Page Object страницы (pages/)

## Базовое взаимодействие со страницей
Основная библиотека используемая для взаимодействия с веб страницей это [Selene](https://github.com/yashaka/selene)
Пример использования:

```python
from selene.api import s, ss, by, be

s('#id').should(be.visible)  # поиск компонента с id=id и проверяет, что компонент виден
ss(by.xpath('//div')).should(be.hidden)  # поиск всех div на странице и проверка, что они не видны
```


## Базовые элементы

Базовые элементы - это небольшие классы реализующие логику по поиску и управлению какими-то Scalr компонентами на странице, например кнопка, Input и т.п.
Например, компонент utils/components/Button реализует поиск кнопки на странице по нескольким параметрам: текст, иконка, а 
компонент Combobox инкапсулирует в себе логику по открытию/закрытию и взаимодействую с combobox.

Также эти компоненты проксируют все не реализованные у себя методы в SeleneElement


## Классы страниц

Эти классы описывают весь необходимый в тестах функционал отдельно взятой страницы Scalr, к примеру Login Page.
Они содержат элементы, с которыми можно взаимодействовать:

```python
from pages.login import LoginPage
page = LoginPage()
page.set_username('test')
page.set_password('password')
page.submit()
```

При инициализации класса страницы, запускается ожидание, что эта страница открылась с помощью автоматического вызова метода wait_page_loading.


## Фикстуры
На данный момент присутствуют следующие фикстуры:
* tf_dashboard - фикстура, которая автоматически авторизует и заходит на Terraform Environment
* testenv - запуск контейнера либо использование уже запущенного контейнера (передача контейнера через опцию --te-id при запуске)


## Запуск тестов

Запускать тесты надо из папки revizor-tests. Возможные опции для запуска:

* --te-id - указание id контейнера на котором запускать тест. Если
* --te-remove - удалять контейнер после тестов или нет
* --scalr-branch - указание бранча для созадваемого контейнера
* --browser - указание браузера для запуска (chrome, firefox)
* --grid-address - адрес удаленного grid'а (для запуска на удаленном сервере)


# Написание новых "страниц"

При написнии новых PageObject объектов (страниц), следует руководствоваться следующими правилами:

1. Стараться использовать элементы из utils/components.
2. Если мы хотим вернуть какой-то selene элемент, то оборачиваем этот метод в property
3. Именовать проперти необходимо с описанием компонента. Если возвращается кнопка, то элемент следует назвать с суффиксом *button*:
    ```python
    @property
    def refresh_button(self) -> components.button:
       return components.button("OK")
    ``` 
4. Если при нажатии на кнопку, происходит открытие новой страницы или модального окна, то надо создать метод с именем open_, который нажмет кнопку и вернет объект страницы:
    ```python
    def open_new_workspace(self) -> NewWorkspaceModal:
        self.new_workspace_button.click()
        return NewWorkspaceModal()
    ```
5. Используйте для объектов страниц наследовние от TfBasePage для доступа к self.menu, а также для запуска метода wait_page_loading
    ```python
    from .base import TfBasePage
    from ui.utils import consts
    from ui.utils import components
    
    class TerraformEnvDashboard(TfBasePage):
        @staticmethod
        def wait_page_loading():
            components.loading_modal(consts.LoadingModalMessages.LOADING_PAGE).should(be.not_.visible)
    ```
6. Называйте классы в соответствии с тем, что это за элемент на странице. Например, если новая страница, то суффикс Page, если модальное окно - Modal и т.п.
7. Старайтесь избегать использование time.sleep, делайте явные ожидания
